import request from 'supertest';
import { cleanDatabase } from '../helpers/database';
import { getTestApp } from '../helpers/test-app';

// Better Auth uses this cookie name pattern
const SESSION_COOKIE_PREFIX = 'better-auth.session_token';

describe('E2E: GET /v1/auth/me', () => {
  let baseUrl: string;

  beforeAll(() => {
    baseUrl = getTestApp();
  });

  beforeEach(async () => {
    await cleanDatabase();
  });

  describe('Cookie-based Authentication', () => {
    it('should return current user with valid session cookie', async () => {
      // Register and login
      const loginResponse = await request(baseUrl)
        .post('/v1/auth/register')
        .send({
          email: 'cookieuser@example.com',
          password: 'SecurePassword123!',
          name: 'Cookie User',
        });

      const cookies = loginResponse.headers['set-cookie'];
      const cookieArray = Array.isArray(cookies) ? cookies : cookies ? [cookies] : [];
      const sessionCookie = cookieArray.find((c: string) => c.includes(SESSION_COOKIE_PREFIX));

      // Access /me endpoint with cookie
      const response = await request(baseUrl)
        .get('/v1/auth/me')
        .set('Cookie', sessionCookie!);

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty('user');
      expect(response.body.user).toMatchObject({
        email: 'cookieuser@example.com',
        name: 'Cookie User',
        emailVerified: false,
      });
      expect(response.body.user).toHaveProperty('id');
      expect(response.body.user).toHaveProperty('birthdate');
      expect(response.body.user).toHaveProperty('createdAt');
      expect(response.body.user).toHaveProperty('updatedAt');
      expect(response.body.authType).toBe('cookie');
    });

    it('should reject request without session cookie', async () => {
      const response = await request(baseUrl)
        .get('/v1/auth/me');

      expect(response.status).toBe(401);
      expect(response.body).toHaveProperty('error');
    });

    it('should reject request with invalid session cookie', async () => {
      const response = await request(baseUrl)
        .get('/v1/auth/me')
        .set('Cookie', `${SESSION_COOKIE_PREFIX}=invalid-session-token-xyz`);

      expect(response.status).toBe(401);
      expect(response.body).toHaveProperty('error');
    });

    it('should reject request with expired session cookie', async () => {
      // This test would require time travel or manipulating the session
      // For now, we test with an invalid token format
      const response = await request(baseUrl)
        .get('/v1/auth/me')
        .set('Cookie', `${SESSION_COOKIE_PREFIX}=expired-token`);

      expect(response.status).toBe(401);
    });
  });

  describe('Bearer Token Authentication', () => {
    it('should return current user with valid bearer token', async () => {
      // Register and get bearer token
      const registerResponse = await request(baseUrl)
        .post('/v1/auth/register')
        .send({
          email: 'beareruser@example.com',
          password: 'SecurePassword123!',
          name: 'Bearer User',
          birthdate: '1998-03-21',
        });

      const accessToken = registerResponse.body.accessToken; // JWT token
      const sessionToken = registerResponse.body.sessionToken;
      const bearerToken = accessToken || sessionToken;

      // Access /me endpoint with bearer token
      const response = await request(baseUrl)
        .get('/v1/auth/me')
        .set('Authorization', `Bearer ${bearerToken}`);

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty('user');
      expect(response.body.user).toMatchObject({
        email: 'beareruser@example.com',
        name: 'Bearer User',
      });
      expect(['bearer-jwt', 'bearer-session']).toContain(response.body.authType);
    });

    it('should reject request without authorization header', async () => {
      const response = await request(baseUrl)
        .get('/v1/auth/me');

      expect(response.status).toBe(401);
      expect(response.body).toHaveProperty('error');
    });

    it('should reject request with invalid bearer token', async () => {
      const response = await request(baseUrl)
        .get('/v1/auth/me')
        .set('Authorization', 'Bearer invalid-token-xyz-123');

      expect(response.status).toBe(401);
      expect(response.body).toHaveProperty('error');
    });

    it('should reject request with malformed authorization header', async () => {
      const response = await request(baseUrl)
        .get('/v1/auth/me')
        .set('Authorization', 'InvalidFormat token-here');

      expect(response.status).toBe(401);
    });

    it('should reject request with missing Bearer prefix', async () => {
      const response = await request(baseUrl)
        .get('/v1/auth/me')
        .set('Authorization', 'some-token-without-bearer-prefix');

      expect(response.status).toBe(401);
    });
  });

  describe('Authentication Type Detection', () => {
    it('should correctly identify cookie-based authentication', async () => {
      const loginResponse = await request(baseUrl)
        .post('/v1/auth/register')
        .send({
          email: 'cookiedetect@example.com',
          password: 'SecurePassword123!',
          name: 'Cookie Detect User',
          birthdate: '1999-07-04',
        });

      const cookies = loginResponse.headers['set-cookie'];
      const cookieArray = Array.isArray(cookies) ? cookies : cookies ? [cookies] : [];
      const sessionCookie = cookieArray.find((c: string) => c.includes(SESSION_COOKIE_PREFIX));

      const response = await request(baseUrl)
        .get('/v1/auth/me')
        .set('Cookie', sessionCookie!);

      expect(response.status).toBe(200);
      expect(response.body.authType).toBe('cookie');
    });

    it('should correctly identify bearer token authentication', async () => {
      const registerResponse = await request(baseUrl)
        .post('/v1/auth/register')
        .send({
          email: 'bearerdetect@example.com',
          password: 'SecurePassword123!',
          name: 'Bearer Detect User',
          birthdate: '2000-12-25',
        });

      const accessToken = registerResponse.body.accessToken; // JWT token

      const response = await request(baseUrl)
        .get('/v1/auth/me')
        .set('Authorization', `Bearer ${accessToken}`);

      expect(response.status).toBe(200);
      expect(response.body.authType).toBe('bearer-jwt');
    });

    it('should prioritize bearer token when both cookie and token present', async () => {
      // Register two users
      const user1 = await request(baseUrl)
        .post('/v1/auth/register')
        .send({
          email: 'user1@example.com',
          password: 'SecurePassword123!',
        });

      const user2 = await request(baseUrl)
        .post('/v1/auth/register')
        .send({
          email: 'user2@example.com',
          password: 'SecurePassword123!',
        });

      const user1Cookies = user1.headers['set-cookie'];
      const user1CookieArray = Array.isArray(user1Cookies) ? user1Cookies : user1Cookies ? [user1Cookies] : [];
      const sessionCookie = user1CookieArray.find((c: string) => c.includes(SESSION_COOKIE_PREFIX));
      const accessToken = user2.body.accessToken; // JWT token

      // Send request with both
      const response = await request(baseUrl)
        .get('/v1/auth/me')
        .set('Cookie', sessionCookie!)
        .set('Authorization', `Bearer ${accessToken}`);

      expect(response.status).toBe(200);
      // Should use JWT token (user2)
      expect(response.body.authType).toBe('bearer-jwt');
      expect(response.body.user.email).toBe('user2@example.com');
    });
  });

  describe('User Data Completeness', () => {
    it('should return all expected user fields', async () => {
      const registerResponse = await request(baseUrl)
        .post('/v1/auth/register')
        .send({
          email: 'complete@example.com',
          password: 'SecurePassword123!',
          name: 'Complete User',
        });

      const accessToken = registerResponse.body.accessToken; // JWT token

      const response = await request(baseUrl)
        .get('/v1/auth/me')
        .set('Authorization', `Bearer ${accessToken}`);

      expect(response.status).toBe(200);
      expect(response.body.user).toHaveProperty('id');
      expect(response.body.user).toHaveProperty('email');
      expect(response.body.user).toHaveProperty('name');
      expect(response.body.user).toHaveProperty('emailVerified');
      expect(response.body.user).toHaveProperty('createdAt');
      expect(response.body.user).toHaveProperty('updatedAt');

      // Should NOT include sensitive fields
      expect(response.body.user).not.toHaveProperty('password');
      expect(response.body.user).not.toHaveProperty('passwordHash');
    });

    it('should not expose sensitive information', async () => {
      const registerResponse = await request(baseUrl)
        .post('/v1/auth/register')
        .send({
          email: 'secure@example.com',
          password: 'SecurePassword123!',
        });

      const accessToken = registerResponse.body.accessToken; // JWT token

      const response = await request(baseUrl)
        .get('/v1/auth/me')
        .set('Authorization', `Bearer ${accessToken}`);

      expect(response.status).toBe(200);

      // Verify no sensitive data in response
      const responseStr = JSON.stringify(response.body);
      expect(responseStr).not.toContain('SecurePassword123!');
      expect(response.body.user).not.toHaveProperty('password');
      expect(response.body.user).not.toHaveProperty('passwordHash');
    });
  });

  describe('Session Persistence', () => {
    it('should maintain session across multiple requests', async () => {
      const registerResponse = await request(baseUrl)
        .post('/v1/auth/register')
        .send({
          email: 'persistent@example.com',
          password: 'SecurePassword123!',
        });

      const accessToken = registerResponse.body.accessToken; // JWT token

      // Make multiple requests with the same token
      for (let i = 0; i < 3; i++) {
        const response = await request(baseUrl)
          .get('/v1/auth/me')
          .set('Authorization', `Bearer ${accessToken}`);

        expect(response.status).toBe(200);
        expect(response.body.user.email).toBe('persistent@example.com');
      }
    });
  });

  describe('Family Membership Data (T016)', () => {
    it('should include families array in response', async () => {
      const registerResponse = await request(baseUrl)
        .post('/v1/auth/register')
        .send({
          email: 'familytest@example.com',
          password: 'SecurePassword123!',
        });

      const accessToken = registerResponse.body.accessToken || registerResponse.body.sessionToken;

      const response = await request(baseUrl)
        .get('/v1/auth/me')
        .set('Authorization', `Bearer ${accessToken}`);

      expect(response.status).toBe(200);
      expect(response.body.user).toHaveProperty('families');
      expect(Array.isArray(response.body.user.families)).toBe(true);
    });

    it('should return empty families array for new user', async () => {
      const registerResponse = await request(baseUrl)
        .post('/v1/auth/register')
        .send({
          email: 'nofamilies@example.com',
          password: 'SecurePassword123!',
        });

      const accessToken = registerResponse.body.accessToken || registerResponse.body.sessionToken;

      const response = await request(baseUrl)
        .get('/v1/auth/me')
        .set('Authorization', `Bearer ${accessToken}`);

      expect(response.status).toBe(200);
      expect(response.body.user.families).toEqual([]);
    });

    it('should include family after creating one', async () => {
      const registerResponse = await request(baseUrl)
        .post('/v1/auth/register')
        .send({
          email: 'withfamily@example.com',
          password: 'SecurePassword123!',
        });

      const accessToken = registerResponse.body.accessToken || registerResponse.body.sessionToken;

      // Create a family
      const createResponse = await request(baseUrl)
        .post('/v1/families')
        .set('Authorization', `Bearer ${accessToken}`)
        .send({
          name: 'Test Family',
        });

      expect(createResponse.status).toBe(201);

      // Check /me includes the family
      const meResponse = await request(baseUrl)
        .get('/v1/auth/me')
        .set('Authorization', `Bearer ${accessToken}`);

      expect(meResponse.status).toBe(200);
      expect(meResponse.body.user.families).toHaveLength(1);
      expect(meResponse.body.user.families[0]).toMatchObject({
        name: 'Test Family',
        role: 'Parent',
      });
      expect(meResponse.body.user.families[0]).toHaveProperty('familyId');
      expect(meResponse.body.user.families[0]).toHaveProperty('linkedAt');
    });

    it('should include multiple families after creating them', async () => {
      const registerResponse = await request(baseUrl)
        .post('/v1/auth/register')
        .send({
          email: 'multifamily@example.com',
          password: 'SecurePassword123!',
        });

      const accessToken = registerResponse.body.accessToken || registerResponse.body.sessionToken;

      // Create first family
      await request(baseUrl)
        .post('/v1/families')
        .set('Authorization', `Bearer ${accessToken}`)
        .send({ name: 'Family One' });

      // Create second family
      await request(baseUrl)
        .post('/v1/families')
        .set('Authorization', `Bearer ${accessToken}`)
        .send({ name: 'Family Two' });

      // Check /me includes both families
      const meResponse = await request(baseUrl)
        .get('/v1/auth/me')
        .set('Authorization', `Bearer ${accessToken}`);

      expect(meResponse.status).toBe(200);
      expect(meResponse.body.user.families).toHaveLength(2);

      const familyNames = meResponse.body.user.families.map((f: any) => f.name);
      expect(familyNames).toContain('Family One');
      expect(familyNames).toContain('Family Two');
    });

    it('should include families with cookie-based authentication', async () => {
      const registerResponse = await request(baseUrl)
        .post('/v1/auth/register')
        .send({
          email: 'cookiefamily@example.com',
          password: 'SecurePassword123!',
        });

      const cookies = registerResponse.headers['set-cookie'];
      const cookieArray = Array.isArray(cookies) ? cookies : cookies ? [cookies] : [];
      const sessionCookie = cookieArray.find((c: string) => c.includes(SESSION_COOKIE_PREFIX));
      const accessToken = registerResponse.body.accessToken || registerResponse.body.sessionToken;

      // Create a family
      await request(baseUrl)
        .post('/v1/families')
        .set('Authorization', `Bearer ${accessToken}`)
        .send({ name: 'Cookie Family' });

      // Check /me with cookie auth includes the family
      const meResponse = await request(baseUrl)
        .get('/v1/auth/me')
        .set('Cookie', sessionCookie!);

      expect(meResponse.status).toBe(200);
      expect(meResponse.body.authType).toBe('cookie');
      expect(meResponse.body.user.families).toHaveLength(1);
      expect(meResponse.body.user.families[0].name).toBe('Cookie Family');
    });
  });
});
