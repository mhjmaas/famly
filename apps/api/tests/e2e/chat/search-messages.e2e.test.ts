import request from "supertest";
import { cleanDatabase } from "../helpers/database";
import { getTestApp } from "../helpers/test-app";
import { registerTestUser } from "../helpers/auth-setup";

describe("E2E: GET /v1/search/messages - Search Messages", () => {
  let baseUrl: string;
  let testCounter = 0;

  beforeAll(() => {
    baseUrl = getTestApp();
  });

  beforeEach(async () => {
    await cleanDatabase();
    testCounter++;
  });

  describe("Success Cases", () => {
    it("should search messages by text query", async () => {
      const user1 = await registerTestUser(baseUrl, testCounter++, "search");
      const user2 = await registerTestUser(baseUrl, testCounter++, "search");

      // Create DM
      const chatRes = await request(baseUrl)
        .post("/v1/chats")
        .set("Authorization", `Bearer ${user1.token}`)
        .send({
          type: "dm",
          memberIds: [user2.userId],
        });

      const chatId = chatRes.body._id;

      // Create messages with different content
      await request(baseUrl)
        .post("/v1/messages")
        .set("Authorization", `Bearer ${user1.token}`)
        .send({
          chatId,
          body: "Let's plan the family dinner",
        });

      await request(baseUrl)
        .post("/v1/messages")
        .set("Authorization", `Bearer ${user2.token}`)
        .send({
          chatId,
          body: "I love pizza for dinner",
        });

      await request(baseUrl)
        .post("/v1/messages")
        .set("Authorization", `Bearer ${user1.token}`)
        .send({
          chatId,
          body: "Tomorrow's weather looks great",
        });

      // Search for "dinner"
      const searchRes = await request(baseUrl)
        .get(`/v1/search/messages?q=dinner`)
        .set("Authorization", `Bearer ${user1.token}`);

      expect(searchRes.status).toBe(200);
      expect(searchRes.body).toHaveProperty("messages");
      expect(Array.isArray(searchRes.body.messages)).toBe(true);
      expect(searchRes.body.messages.length).toBe(2);

      // Both messages should contain "dinner"
      const bodies = searchRes.body.messages.map((m: any) => m.body);
      expect(bodies).toContain("Let's plan the family dinner");
      expect(bodies).toContain("I love pizza for dinner");
    });

    it("should search messages within specific chat", async () => {
      const user1 = await registerTestUser(baseUrl, testCounter++, "search");
      const user2 = await registerTestUser(baseUrl, testCounter++, "search");
      const user3 = await registerTestUser(baseUrl, testCounter++, "search");

      // Create DM1 between user1 and user2
      const chat1Res = await request(baseUrl)
        .post("/v1/chats")
        .set("Authorization", `Bearer ${user1.token}`)
        .send({
          type: "dm",
          memberIds: [user2.userId],
        });

      const chatId1 = chat1Res.body._id;

      // Create DM2 between user1 and user3
      const chat2Res = await request(baseUrl)
        .post("/v1/chats")
        .set("Authorization", `Bearer ${user1.token}`)
        .send({
          type: "dm",
          memberIds: [user3.userId],
        });

      const chatId2 = chat2Res.body._id;

      // Add "birthday" message to both chats
      await request(baseUrl)
        .post("/v1/messages")
        .set("Authorization", `Bearer ${user1.token}`)
        .send({
          chatId: chatId1,
          body: "Birthday party next week",
        });

      await request(baseUrl)
        .post("/v1/messages")
        .set("Authorization", `Bearer ${user1.token}`)
        .send({
          chatId: chatId2,
          body: "Birthday dinner planned",
        });

      // Search within chatId1 only
      const searchRes = await request(baseUrl)
        .get(`/v1/search/messages?q=birthday&chatId=${chatId1}`)
        .set("Authorization", `Bearer ${user1.token}`);

      expect(searchRes.status).toBe(200);
      expect(searchRes.body.messages.length).toBe(1);
      expect(searchRes.body.messages[0].chatId).toBe(chatId1);
      expect(searchRes.body.messages[0].body).toContain("Birthday party");
    });

    it("should paginate search results", async () => {
      const user1 = await registerTestUser(baseUrl, testCounter++, "search");
      const user2 = await registerTestUser(baseUrl, testCounter++, "search");

      // Create DM
      const chatRes = await request(baseUrl)
        .post("/v1/chats")
        .set("Authorization", `Bearer ${user1.token}`)
        .send({
          type: "dm",
          memberIds: [user2.userId],
        });

      const chatId = chatRes.body._id;

      // Create 5 messages with "test" keyword
      for (let i = 0; i < 5; i++) {
        await request(baseUrl)
          .post("/v1/messages")
          .set("Authorization", `Bearer ${user1.token}`)
          .send({
            chatId,
            body: `Test message number ${i + 1}`,
          });
      }

      // Search with limit=2
      const page1Res = await request(baseUrl)
        .get(`/v1/search/messages?q=test&limit=2`)
        .set("Authorization", `Bearer ${user1.token}`);

      expect(page1Res.status).toBe(200);
      expect(page1Res.body.messages.length).toBe(2);
      expect(page1Res.body.nextCursor).toBeDefined();

      // Get next page
      const page2Res = await request(baseUrl)
        .get(
          `/v1/search/messages?q=test&limit=2&cursor=${page1Res.body.nextCursor}`
        )
        .set("Authorization", `Bearer ${user1.token}`);

      expect(page2Res.status).toBe(200);
      expect(page2Res.body.messages.length).toBe(2);

      // Verify no overlap
      const page1Ids = page1Res.body.messages.map((m: any) => m._id);
      const page2Ids = page2Res.body.messages.map((m: any) => m._id);
      expect(page1Ids.some((id: string) => page2Ids.includes(id))).toBe(false);
    });

    it("should return empty results for non-matching query", async () => {
      const user1 = await registerTestUser(baseUrl, testCounter++, "search");
      const user2 = await registerTestUser(baseUrl, testCounter++, "search");

      // Create DM
      const chatRes = await request(baseUrl)
        .post("/v1/chats")
        .set("Authorization", `Bearer ${user1.token}`)
        .send({
          type: "dm",
          memberIds: [user2.userId],
        });

      const chatId = chatRes.body._id;

      // Create message
      await request(baseUrl)
        .post("/v1/messages")
        .set("Authorization", `Bearer ${user1.token}`)
        .send({
          chatId,
          body: "Hello world",
        });

      // Search for non-matching term
      const searchRes = await request(baseUrl)
        .get(`/v1/search/messages?q=nonexistent`)
        .set("Authorization", `Bearer ${user1.token}`);

      expect(searchRes.status).toBe(200);
      expect(searchRes.body.messages).toEqual([]);
      expect(searchRes.body.nextCursor).toBeUndefined();
    });

    it("should search across multiple chats", async () => {
      const user1 = await registerTestUser(baseUrl, testCounter++, "search");
      const user2 = await registerTestUser(baseUrl, testCounter++, "search");
      const user3 = await registerTestUser(baseUrl, testCounter++, "search");

      // Create group chat with user2
      const group1Res = await request(baseUrl)
        .post("/v1/chats")
        .set("Authorization", `Bearer ${user1.token}`)
        .send({
          type: "group",
          memberIds: [user2.userId],
          title: "Group 1",
        });

      // Create group chat with user3
      const group2Res = await request(baseUrl)
        .post("/v1/chats")
        .set("Authorization", `Bearer ${user1.token}`)
        .send({
          type: "group",
          memberIds: [user3.userId],
          title: "Group 2",
        });

      // Add "meeting" messages to both groups
      await request(baseUrl)
        .post("/v1/messages")
        .set("Authorization", `Bearer ${user1.token}`)
        .send({
          chatId: group1Res.body._id,
          body: "Meeting scheduled for Monday",
        });

      await request(baseUrl)
        .post("/v1/messages")
        .set("Authorization", `Bearer ${user1.token}`)
        .send({
          chatId: group2Res.body._id,
          body: "Meeting with the team tomorrow",
        });

      // Search for "meeting" across all user's chats
      const searchRes = await request(baseUrl)
        .get(`/v1/search/messages?q=meeting`)
        .set("Authorization", `Bearer ${user1.token}`);

      expect(searchRes.status).toBe(200);
      expect(searchRes.body.messages.length).toBe(2);

      // Verify messages from both chats
      const chatIds = new Set(
        searchRes.body.messages.map((m: any) => m.chatId)
      );
      expect(chatIds.has(group1Res.body._id)).toBe(true);
      expect(chatIds.has(group2Res.body._id)).toBe(true);
    });

    it("should use default limit of 20", async () => {
      const user1 = await registerTestUser(baseUrl, testCounter++, "search");
      const user2 = await registerTestUser(baseUrl, testCounter++, "search");

      // Create DM
      const chatRes = await request(baseUrl)
        .post("/v1/chats")
        .set("Authorization", `Bearer ${user1.token}`)
        .send({
          type: "dm",
          memberIds: [user2.userId],
        });

      const chatId = chatRes.body._id;

      // Create 15 messages with "default" keyword
      for (let i = 0; i < 15; i++) {
        await request(baseUrl)
          .post("/v1/messages")
          .set("Authorization", `Bearer ${user1.token}`)
          .send({
            chatId,
            body: `Default limit test ${i + 1}`,
          });
      }

      // Search without limit parameter
      const searchRes = await request(baseUrl)
        .get(`/v1/search/messages?q=default`)
        .set("Authorization", `Bearer ${user1.token}`);

      expect(searchRes.status).toBe(200);
      expect(searchRes.body.messages.length).toBe(15);
      expect(searchRes.body.nextCursor).toBeUndefined();
    });
  });

  describe("Validation Errors", () => {
    it("should reject search without query parameter with 400", async () => {
      const user1 = await registerTestUser(baseUrl, testCounter++, "search");

      const searchRes = await request(baseUrl)
        .get(`/v1/search/messages`)
        .set("Authorization", `Bearer ${user1.token}`);

      expect(searchRes.status).toBe(400);
    });

    it("should reject empty query string with 400", async () => {
      const user1 = await registerTestUser(baseUrl, testCounter++, "search");

      const searchRes = await request(baseUrl)
        .get(`/v1/search/messages?q=`)
        .set("Authorization", `Bearer ${user1.token}`);

      expect(searchRes.status).toBe(400);
    });

    it("should reject invalid limit (> 100) with 400", async () => {
      const user1 = await registerTestUser(baseUrl, testCounter++, "search");

      const searchRes = await request(baseUrl)
        .get(`/v1/search/messages?q=test&limit=500`)
        .set("Authorization", `Bearer ${user1.token}`);

      expect(searchRes.status).toBe(400);
    });

    it("should reject invalid chatId format with 400", async () => {
      const user1 = await registerTestUser(baseUrl, testCounter++, "search");

      const searchRes = await request(baseUrl)
        .get(`/v1/search/messages?q=test&chatId=not-an-object-id`)
        .set("Authorization", `Bearer ${user1.token}`);

      expect(searchRes.status).toBe(400);
    });

    it("should reject invalid cursor format with 400", async () => {
      const user1 = await registerTestUser(baseUrl, testCounter++, "search");

      const searchRes = await request(baseUrl)
        .get(`/v1/search/messages?q=test&cursor=invalid`)
        .set("Authorization", `Bearer ${user1.token}`);

      expect(searchRes.status).toBe(400);
    });

    it("should accept limit=1", async () => {
      const user1 = await registerTestUser(baseUrl, testCounter++, "search");
      const user2 = await registerTestUser(baseUrl, testCounter++, "search");

      // Create DM
      const chatRes = await request(baseUrl)
        .post("/v1/chats")
        .set("Authorization", `Bearer ${user1.token}`)
        .send({
          type: "dm",
          memberIds: [user2.userId],
        });

      const chatId = chatRes.body._id;

      // Create message
      await request(baseUrl)
        .post("/v1/messages")
        .set("Authorization", `Bearer ${user1.token}`)
        .send({
          chatId,
          body: "Test message",
        });

      const searchRes = await request(baseUrl)
        .get(`/v1/search/messages?q=test&limit=1`)
        .set("Authorization", `Bearer ${user1.token}`);

      expect(searchRes.status).toBe(200);
      expect(searchRes.body.messages.length).toBe(1);
    });

    it("should accept limit=100", async () => {
      const user1 = await registerTestUser(baseUrl, testCounter++, "search");

      const searchRes = await request(baseUrl)
        .get(`/v1/search/messages?q=test&limit=100`)
        .set("Authorization", `Bearer ${user1.token}`);

      expect(searchRes.status).toBe(200);
    });
  });

  describe("Authorization Errors", () => {
    it("should require authentication with 401", async () => {
      const searchRes = await request(baseUrl).get(
        `/v1/search/messages?q=test`
      );

      expect(searchRes.status).toBe(401);
    });

    it("should only search user's own chats (no cross-user leakage)", async () => {
      const user1 = await registerTestUser(baseUrl, testCounter++, "search");
      const user2 = await registerTestUser(baseUrl, testCounter++, "search");
      const user3 = await registerTestUser(baseUrl, testCounter++, "search");

      // User1 and User2 create a DM
      const chatRes = await request(baseUrl)
        .post("/v1/chats")
        .set("Authorization", `Bearer ${user1.token}`)
        .send({
          type: "dm",
          memberIds: [user2.userId],
        });

      const chatId = chatRes.body._id;

      // User2 adds a secret message
      await request(baseUrl)
        .post("/v1/messages")
        .set("Authorization", `Bearer ${user2.token}`)
        .send({
          chatId,
          body: "Secret message with keyword unicorn",
        });

      // User3 tries to search for "unicorn" - should not find it
      const searchRes = await request(baseUrl)
        .get(`/v1/search/messages?q=unicorn`)
        .set("Authorization", `Bearer ${user3.token}`);

      expect(searchRes.status).toBe(200);
      expect(searchRes.body.messages.length).toBe(0);
    });
  });

  describe("Message Details", () => {
    it("should include all message fields in search results", async () => {
      const user1 = await registerTestUser(baseUrl, testCounter++, "search");
      const user2 = await registerTestUser(baseUrl, testCounter++, "search");

      // Create DM
      const chatRes = await request(baseUrl)
        .post("/v1/chats")
        .set("Authorization", `Bearer ${user1.token}`)
        .send({
          type: "dm",
          memberIds: [user2.userId],
        });

      const chatId = chatRes.body._id;

      // Create message
      const createRes = await request(baseUrl)
        .post("/v1/messages")
        .set("Authorization", `Bearer ${user1.token}`)
        .send({
          chatId,
          clientId: "search-test",
          body: "Complete message test",
        });

      const messageId = createRes.body._id;

      // Search for message
      const searchRes = await request(baseUrl)
        .get(`/v1/search/messages?q=complete`)
        .set("Authorization", `Bearer ${user1.token}`);

      expect(searchRes.status).toBe(200);
      const message = searchRes.body.messages[0];

      expect(message._id).toBe(messageId);
      expect(message.chatId).toBe(chatId);
      expect(message.senderId).toBe(user1.userId);
      expect(message.body).toBe("Complete message test");
      expect(message.clientId).toBe("search-test");
      expect(message.deleted).toBe(false);
      expect(message.createdAt).toBeDefined();
    });
  });
});
